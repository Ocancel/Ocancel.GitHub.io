<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>DesignPatterns on Ocancel 的博客</title>
        <link>https://Ocancel.GitHub.io/categories/designpatterns/</link>
        <description>Recent content in DesignPatterns on Ocancel 的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 02 Jul 2020 15:31:36 +0800</lastBuildDate><atom:link href="https://Ocancel.GitHub.io/categories/designpatterns/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Design Principle</title>
        <link>https://Ocancel.GitHub.io/post/design-principle/</link>
        <pubDate>Thu, 02 Jul 2020 15:31:36 +0800</pubDate>
        
        <guid>https://Ocancel.GitHub.io/post/design-principle/</guid>
        <description>&lt;h3 id=&#34;i-开闭原则open-closed-principleocp&#34;&gt;I. 开闭原则｜Open-Closed Principle｜OCP&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;对扩展开放，对修改关闭。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;ii-依赖倒置原则dependence-inversion-principledip&#34;&gt;II. 依赖倒置原则｜Dependence Inversion Principle｜DIP&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;高层模块不应该依赖底层模块，二者都应该依赖其抽象。
抽象不应该依赖细节，细节应该依赖抽象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;iii-单一职责原则simple-responsibility-pinciplesrp&#34;&gt;III. 单一职责原则｜Simple Responsibility Pinciple｜SRP&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;不要存在多于一个导致类变更的原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;iv-接口隔离原则interface-segregation-principleisp&#34;&gt;IV. 接口隔离原则｜Interface Segregation Principle｜ISP&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;使用多个专用接口，不使用单一的总接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;v-最少知道原则least-knowledge-principlelkp&#34;&gt;V. 最少知道原则｜Least Knowledge Principle｜LKP&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;一个对象应该对其他对象保持最少的了解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;vi-里氏替换原则liskov-substitution-principlelsp&#34;&gt;VI. 里氏替换原则｜Liskov Substitution Principle｜LSP&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;若对于任意的类型为&lt;code&gt;T1&lt;/code&gt;的对象&lt;code&gt;O1&lt;/code&gt;，都有类型为&lt;code&gt;T2&lt;/code&gt;的对象&lt;code&gt;O2&lt;/code&gt;，使得以&lt;code&gt;T1&lt;/code&gt;定义的所有程序&lt;code&gt;P&lt;/code&gt;在所有的对象&lt;code&gt;O1&lt;/code&gt;都替换成&lt;code&gt;O2&lt;/code&gt;时，程序&lt;code&gt;P&lt;/code&gt;的行为没有发生变化，则类型&lt;code&gt;T2&lt;/code&gt;是类型&lt;code&gt;T1&lt;/code&gt;的子类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;引申含义：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;子类可以扩展父类的功能，但不能改变父类原有的功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;vii-合成复用原则composite--aggregate-reuse-principlecarp&#34;&gt;VII. 合成复用原则｜Composite / Aggregate Reuse Principle｜CARP&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;尽量使用对象组合/聚合而不是继承关系达到软件复用的目的。
&lt;strong&gt;白箱复用：&lt;/strong&gt; 指继承，把所有的实现细节暴露给子类。
&lt;strong&gt;黑箱复用：&lt;/strong&gt; 指组合/聚合，无法获取类以外的实现细节。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;设计原则是设计模式的基础，不要求代码完全遵循设计原则，适当的使用设计原则，不要刻意追求完美。&lt;/strong&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
